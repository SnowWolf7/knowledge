## 4 The class File Format

This chapter describes the `class` file format of the Java Virtual Machine. Each
`class` file contains the definition of a single class or interface. Although a class or
interface need not have an external representation literally contained in a file (for
instance, because the class is generated by a class loader), we will colloquially refer
to any valid representation of a class or interface as being in the `class` file format.

A `class` file consists of a stream of 8-bit bytes. All 16-bit, 32-bit, and 64-bit
quantities are constructed by reading in two, four, and eight consecutive 8-bit
bytes, respectively. Multibyte data items are always stored in big-endian order,
where the high bytes come first. In the Java SE platform, this format is supported
by interfaces `java.io.DataInput` and `java.io.DataOutput` and classes such as
`java.io.DataInputStream` and `java.io.DataOutputStream`.

This chapter defines its own set of data types representing `class` file data: The
types `u1`, `u2`, and `u4` represent an unsigned one-, two-, or four-byte quantity,
respectively. In the Java SE platform, these types may be read by methods
such as `readUnsignedByte`, `readUnsignedShort`, and `readInt` of the interface
`java.io.DataInput`.

This chapter presents the `class` file format using pseudostructures written in a
C-like structure notation. To avoid confusion with the fields of classes and class
instances, etc., the contents of the structures describing the `class` file format are
referred to as *items*. Successive items are stored in the `class` file sequentially,
without padding or alignment.

*Tables*, consisting of zero or more variable-sized items, are used in several `class` file structures. Although we use C-like array syntax to refer to table items, the fact
that tables are streams of varying-sized structures means that it is not possible to
translate a table index directly to a byte offset into the table.

Where we refer to a data structure as an *array*, it consists of zero or more contiguous
fixed-sized items and can be indexed like an array.

Reference to an ASCII character in this chapter should be interpreted to mean the
Unicode code point corresponding to the ASCII character.

### 4.1 The `classFile` Structure

A `class` file consists of a single `ClassFile` structure:

```java
ClassFile {
    u4					magic;
    u2					minor_version;
    u2					major_version;
    u2					constant_pool_count;
    cp_info				constant_pool_count[constant_pool_count-1];
    u2					access_flags;
    u2					this_class;
    u2					super_class;
    u2					interfaces_count;
    u2					interfaces[interfaces_count];
    u2					fields_count;
    field_info			fields[fields_count];
    u2					methods_count;
    method_info			methods[methods_count];
    u2					attributes_count;
    attribute_info		attributes[attributes_count];
}
```

The items in the `classFile` structure are as follows:

+ magic
    The `magic` item supplies the magic number identifying the `class` file format;
    it has the value `0xCAFEBABE`.

+ minor_version, major_version

    The values of the `minor_version` and `major_version` items are the minor and
    major version numbers of this `class` file. Together, a major and a minor version
    number determine the version of the `class` file format. If a `class` file has major
    version number M and minor version number m, we denote the version of its
    `class` file format as M.m. Thus, `class` file format versions may be ordered
    lexicographically, for example, 1.5 < 2.0 < 2.1.

    A Java Virtual Machine implementation can support a `class` file format of
    version v if and only if v lies in some contiguous range Mi.0 ≤ v ≤ Mj.m.
    The release level of the Java SE platform to which a Java Virtual Machine
    implementation conforms is responsible for determining the range.

+ constant_pool_count

    The value of the `constant_pool_count` item is equal to the number of entries
    in the `constant_pool` table plus one. A `constant_pool` index is considered
    valid if it is greater than zero and less than `constant_pool_count`, with the
    exception for constants of type `long` and `double` noted in §4.4.5.

+ constant_poo[]

    The `constant_pool` is a table of structures (§4.4) representing various string
    constants, class and interface names, field names, and other constants that are
    referred to within the `ClassFile` structure and its substructures. The format of
    each `constant_pool` table entry is indicated by its first "tag" byte.

    The `constant_pool` table is indexed from 1 to `constant_pool_count` - 1.

+ access_flags

    The value of the `access_flags` item is a mask of flags used to denote access
    permissions to and properties of this class or interface. The interpretation of
    each flag, when set, is specified in Table 4.1-A.

    **Table 4.1-A. Class access and property modifiers**

    | Flag Name      | Value  | Interpretation                                               |
    | -------------- | ------ | ------------------------------------------------------------ |
    | ACC_PUBLIC     | 0x0001 | Declared `public`; may be accessed from outside its package. |
    | ACC_FINAL      | 0x0010 | Declared `final`; no subclasses allowed.                     |
    | ACC_SUPER      | 0x0020 | Treat superclass methods specially when invoked by the *invokespecial* instruction. |
    | ACC_INTERFACE  | 0x0200 | Is an interface, not a class.                                |
    | ACC_ABSTRACT   | 0x0400 | Declared `abstract`; must not be instantiated.               |
    | ACC_SYNTHETIC  | 0x1000 | Declared `synthetic`; not present in the source code.        |
    | ACC_ANNOTATION | 0x2000 | Declared as an annotation type.                              |
    | ACC_ENUM       | 0x4000 | Declared as an `enum` type.                                  |

    An interface is distinguished by the `ACC_INTERFACE` flag being set. If the
    `ACC_INTERFACE flag` is not set, this `class` file defines a class, not an interface.

### 4.2 The Internal Form of Names

### 4.3 Descriptors

### 4.4 The Constant Pool

### 4.5 Fields

### 4.6 Methods

### 4.7 Attributes

### 4.8 Format Checking

### 4.9 Constraints on Java Virtual Machine Code

### 4.10 Vertification of `class` Files

### 4.11 Limitations of the Java Virtual  Machine

The following limitations of the Java Virtual Machine are implicit in the `class`
file format:

+ The per-class or per-interface constant pool is limited to 65535 entries by the 16-
    bit `constant_pool_count` field of the `ClassFile` structure (§4.1). This acts as
    an internal limit on the total complexity of a single class or interface.

+ The number of fields that may be declared by a class or interface is limited to
    65535 by the size of the `fields_count` item of the `ClassFile` structure (§4.1).

    Note that the value of the `fields_count` item of the `ClassFile` structure does
    not include fields that are inherited from superclasses or superinterfaces.

+ The number of methods that may be declared by a class or interface is limited to
    65535 by the size of the `methods_count` item of the `ClassFile` structure (§4.1).

    Note that the value of the `methods_count` item of the `ClassFile` structure does
    not include methods that are inherited from superclasses or superinterfaces.

+ The number of direct superinterfaces of a class or interface is limited to 65535
    by the size of the `interfaces_count` item of the `ClassFile` structure (§4.1).

+ The greatest number of local variables in the local variables array of a frame
    created upon invocation of a method (§2.6) is limited to 65535 by the size of the
    `max_locals` item of the `Code` attribute (§4.7.3) giving the code of the method,
    and by the 16-bit local variable indexing of the Java Virtual Machine instruction
    set.

    Note that values of type `long` and `double` are each considered to reserve two
    local variables and contribute two units toward the `max_locals` value, so use of
    local variables of those types further reduces this limit.

+ The size of an operand stack in a frame (§2.6) is limited to 65535 values by the
    `max_stack` field of the `Code` attribute (§4.7.3).

    Note that values of type `long` and `double` are each considered to contribute two
    units toward the `max_stack` value, so use of values of these types on the operand
    stack further reduces this limit.

+ The number of method parameters is limited to 255 by the definition of a method
    descriptor (§4.3.3), where the limit includes one unit for `this` in the case of
    instance or interface method invocations.

    Note that a method descriptor is defined in terms of a notion of method parameter
    length in which a parameter of type `long` or `double` contributes two units to the
    length, so parameters of these types further reduce the limit.

+ The length of field and method names, field and method descriptors, and other
    constant string values (including those referenced by `ConstantValue` (§4.7.2)
    attributes) is limited to 65535 characters by the 16-bit unsigned `length` item of
    the `CONSTANT_Utf8_info` structure (§4.4.7).

    Note that the limit is on the number of bytes in the encoding and not on
    the number of encoded characters. UTF-8 encodes some characters using two
    or three bytes. Thus, strings incorporating multibyte characters are further
    constrained

+ The number of dimensions in an array is limited to 255 by the size of the
    *dimensions* opcode of the *multianewarray* instruction and by the constraints
    imposed on the *multianewarray*, *anewarray*, and *newarray* instructions (§4.9.1,
    §4.9.2).